================================================================================
                    DOCUMENTA√á√ÉO COMPLETA - MySabich√£o
================================================================================

√çNDICE
================================================================================

1Ô∏è‚É£  Vis√£o Geral do Projeto
2Ô∏è‚É£  Arquitetura Geral
3Ô∏è‚É£  Stack Tecnol√≥gica
4Ô∏è‚É£  L√≥gica do Chat com IA
5Ô∏è‚É£  Componentes Reutiliz√°veis
6Ô∏è‚É£  L√≥gica de Neg√≥cio
7Ô∏è‚É£  Gest√£o de Estado e Dados
8Ô∏è‚É£  Autentica√ß√£o e Seguran√ßa
9Ô∏è‚É£  Integra√ß√£o com IA
üîü  Guia de Replica√ß√£o para Novo Projeto
1Ô∏è‚É£1Ô∏è‚É£  Boas Pr√°ticas e Recomenda√ß√µes

================================================================================
1Ô∏è‚É£  VIS√ÉO GERAL DO PROJETO
================================================================================

FINALIDADE
----------
O MySabich√£o √© um assistente virtual inteligente com IA que permite aos
utilizadores fazer qualquer tipo de d√∫vida e receber respostas inteligentes.
Utiliza RAG (Retrieval Augmented Generation) para acessar documentos da empresa.

Funcionalidades principais:
- Consultas sobre dados e informa√ß√µes da empresa
- An√°lise de dados e relat√≥rios
- Perguntas sobre informa√ß√µes armazenadas no sistema
- D√∫vidas sobre templates e formul√°rios
- Orienta√ß√£o sobre dados hist√≥ricos e estat√≠sticas
- Informa√ß√µes extra√≠das de documentos da empresa (PDFs, DOCX, TXT) que foram
  processados e indexados

P√öBLICO-ALVO
------------
- Funcion√°rios da empresa que precisam de informa√ß√µes r√°pidas
- Utilizadores que precisam de ajuda com processos do sistema
- Administradores que gerem documentos e conhecimento

PROBLEMA QUE RESOLVE
--------------------
- Acesso r√°pido a informa√ß√µes da empresa sem consultar m√∫ltiplas fontes
- Respostas baseadas em documentos internos processados
- Suporte automatizado para processos e funcionalidades do sistema
- Centraliza√ß√£o do conhecimento organizacional

PRINCIPAIS FUNCIONALIDADES
---------------------------
1. Chat Principal (MySabich√£o): Responde perguntas usando RAG com documentos
   da empresa
2. Chat de Suporte: Ajuda com processos e uso do sistema
3. Gest√£o de Documentos: Upload, processamento e indexa√ß√£o de documentos
4. Hist√≥rico de Conversas: Persist√™ncia e recupera√ß√£o de conversas anteriores
5. Contexto Separado: Conversas separadas por contexto (sabichao/support)

================================================================================
2Ô∏è‚É£  ARQUITETURA GERAL
================================================================================

TIPO DE ARQUITETURA
-------------------
Arquitetura full-stack separada em frontend e backend, com comunica√ß√£o via
API REST.

ORGANIZA√á√ÉO DAS PASTAS
----------------------

raf-mapa-producao-app/
‚îú‚îÄ‚îÄ client/                    # Frontend Next.js
‚îÇ   ‚îú‚îÄ‚îÄ app/                  # App Router do Next.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/              # API Routes (proxy, upload)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mysabichao/       # P√°gina do MySabich√£o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ components/           # Componentes React
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mysabichao/      # Componentes espec√≠ficos do chat
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ support/         # Componentes do chat de suporte
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/              # Componentes UI reutiliz√°veis
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ lib/                  # Utilit√°rios e helpers
‚îÇ       ‚îú‚îÄ‚îÄ api-client.ts    # Cliente API
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îî‚îÄ‚îÄ server/                   # Backend Express
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ config/          # Configura√ß√µes (DB, etc)
    ‚îÇ   ‚îú‚îÄ‚îÄ controllers/      # L√≥gica de neg√≥cio
    ‚îÇ   ‚îú‚îÄ‚îÄ models/           # Modelos de dados (MongoDB)
    ‚îÇ   ‚îú‚îÄ‚îÄ routes/           # Defini√ß√£o de rotas
    ‚îÇ   ‚îú‚îÄ‚îÄ services/         # Servi√ßos (OpenAI, RAG, etc)
    ‚îÇ   ‚îú‚îÄ‚îÄ middleware/       # Middlewares (auth, etc)
    ‚îÇ   ‚îî‚îÄ‚îÄ types/            # Tipos TypeScript

SEPARA√á√ÉO DE RESPONSABILIDADES
-------------------------------

Frontend (Next.js 16 + React 19):
- UI/UX: Componentes React com Tailwind CSS
- Autentica√ß√£o: Clerk (via @clerk/nextjs)
- Comunica√ß√£o: API proxy para backend
- Estado: React hooks (useState, useEffect)
- Roteamento: Next.js App Router

Backend (Express + TypeScript):
- API REST: Endpoints para chat, documentos, etc.
- Autentica√ß√£o: Clerk backend (@clerk/backend)
- Persist√™ncia: MongoDB
- IA: OpenAI API (GPT-4o-mini)
- RAG: Processamento e busca sem√¢ntica de documentos

FLUXO GERAL DE DADOS
--------------------

1. Utilizador envia mensagem no frontend
   ‚Üì
2. Frontend chama apiClient.chat.sendMessage()
   ‚Üì
3. Request vai para /api/proxy/[...path] (Next.js API Route)
   ‚Üì
4. API Route adiciona token Clerk e faz proxy para backend Express
   ‚Üì
5. Backend middleware autentica token com Clerk
   ‚Üì
6. ChatController.sendMessage() processa:
   - Busca hist√≥rico da conversa
   - Se contexto 'sabichao': busca chunks relevantes via RAG
   - Constr√≥i prompt com contexto
   - Chama OpenAI API
   - Salva mensagens no MongoDB
   ‚Üì
7. Resposta retornada ao frontend
   ‚Üì
8. Frontend atualiza UI com nova mensagem

================================================================================
3Ô∏è‚É£  STACK TECNOL√ìGICA
================================================================================

LINGUAGENS
----------
- TypeScript (frontend e backend)
- JavaScript (runtime)

FRAMEWORKS E BIBLIOTECAS PRINCIPAIS
------------------------------------

Frontend:
- Next.js 16.1.1 (React framework)
- React 19.2.3
- Tailwind CSS 4 (styling)
- Framer Motion 12.24.12 (anima√ß√µes)
- Radix UI (componentes acess√≠veis)
- React Hook Form 7.70.0 (formul√°rios)
- Zod 4.3.5 (valida√ß√£o)
- Recharts 3.6.0 (gr√°ficos)
- Sonner 2.0.7 (toasts)

Backend:
- Express 4.18.2 (web framework)
- MongoDB 7.0.0 (driver)
- OpenAI 6.16.0 (SDK)
- Multer 1.4.5-lts.1 (upload de ficheiros)
- pdf-parse 1.1.4 (extra√ß√£o de PDF)
- mammoth 1.11.0 (extra√ß√£o de DOCX)
- Helmet 8.1.0 (seguran√ßa)
- express-rate-limit 8.2.1 (rate limiting)
- CORS 2.8.5

SERVI√áOS EXTERNOS
-----------------
1. Clerk: Autentica√ß√£o e gest√£o de utilizadores
2. OpenAI: GPT-4o-mini e text-embedding-3-small
3. MongoDB: Base de dados NoSQL

FERRAMENTAS DE BUILD E DESENVOLVIMENTO
--------------------------------------
- TypeScript 5.3.3
- tsx 4.7.0 (execu√ß√£o TypeScript)
- ESLint 9 (linting)
- concurrently 8.2.2 (executar frontend/backend simultaneamente)

================================================================================
4Ô∏è‚É£  L√ìGICA DO CHAT COM IA
================================================================================

COMO O INPUT DO UTILIZADOR √â TRATADO
-------------------------------------

1. Frontend (MySabichaoContent ou SupportChatFab):
   - Cria mensagem do utilizador
   - Adiciona ao estado local
   - Envia via API

2. Envio via API:
   - apiClient.chat.sendMessage(message, conversationId, context)

COMO O PROMPT PARA A IA √â CONSTRU√çDO
-------------------------------------

1. Busca do hist√≥rico:
   - Carrega todas as mensagens da conversa
   - Formata para formato OpenAI

2. Busca RAG (apenas para contexto 'sabichao'):
   - Gera embedding da pergunta
   - Busca chunks relevantes (top 3)
   - Adiciona ao contexto

3. System prompt:
   - Baseado no contexto (sabichao/support)
   - Enriquecido com contexto RAG se dispon√≠vel

4. Chamada OpenAI:
   - Envia mensagens + system prompt
   - Recebe resposta

ESTRAT√âGIA DE CONTEXTO E HIST√ìRICO
-----------------------------------

- ConversationId com prefixo: {context}-{uuid}
  Exemplo: "sabichao-abc123", "support-xyz789"
- Hist√≥rico: Todas as mensagens da conversa s√£o carregadas e enviadas √† OpenAI
- Contexto RAG: Apenas para 'sabichao', busca os 3 chunks mais relevantes
- System prompts diferentes:
  - sabichao: Focado em dados e documentos da empresa
  - support: Focado em processos e uso do sistema

COMO A RESPOSTA DA IA √â PROCESSADA
------------------------------------

1. Rece√ß√£o da resposta da OpenAI
2. Persist√™ncia no MongoDB
3. Retorno ao frontend
4. Atualiza√ß√£o da UI

LIMITA√á√ïES, VALIDA√á√ïES E TRATAMENTO DE ERROS
---------------------------------------------

Valida√ß√µes:
- Mensagem n√£o vazia
- Autentica√ß√£o obrigat√≥ria
- Contexto v√°lido (sabichao/support)

Limita√ß√µes OpenAI:
- Modelo: gpt-4o-mini (configur√°vel)
- Temperature: 0.7
- Max tokens: 1000
- Rate limiting: 100 requests/15min por IP

Tratamento de erros:
- Erros espec√≠ficos da OpenAI (401, 429, 500)
- Toast de erro no frontend
- Remo√ß√£o de mensagem otimista em caso de erro
- Loading state durante processamento

================================================================================
5Ô∏è‚É£  COMPONENTES REUTILIZ√ÅVEIS
================================================================================

COMPONENTES DE UI REUTILIZ√ÅVEIS
-------------------------------

1. V0AIChat (client/components/ui/v0-ai-chat.tsx)
   - Responsabilidade: Interface de chat completa
   - Props: value, onChange, onSend, loading, messages, placeholder, title,
     onQuickAction
   - Funcionalidades:
     * Auto-resize do textarea
     * Scroll autom√°tico para √∫ltima mensagem
     * Bot√µes de a√ß√£o r√°pida
     * Indicador de loading
   - Depend√™ncias: Textarea, Spinner, lucide-react

2. ExpandableChat (client/components/ui/expandable-chat.tsx)
   - Responsabilidade: Chat expans√≠vel (FAB)
   - Props: position, size, icon, children
   - Sub-componentes:
     * ExpandableChatHeader: Cabe√ßalho
     * ExpandableChatBody: Corpo (scrollable)
     * ExpandableChatFooter: Rodap√©

3. ChatBubble (client/components/ui/chat-bubble.tsx)
   - Responsabilidade: Bolha de mensagem
   - Variantes: sent (utilizador) | received (assistente)
   - Sub-componentes:
     * ChatBubbleAvatar: Avatar
     * ChatBubbleMessage: Conte√∫do da mensagem

4. ChatMessageList (client/components/ui/chat-message-list.tsx)
   - Responsabilidade: Container scrollable para mensagens

5. ChatInput (client/components/ui/chat-input.tsx)
   - Responsabilidade: Input de texto para chat

HOOKS REUTILIZ√ÅVEIS
-------------------

1. useAutoScroll (client/components/hooks/use-auto-scroll.ts)
   - Responsabilidade: Scroll autom√°tico para elemento

2. usePagination (client/components/hooks/use-pagination.ts)
   - Responsabilidade: L√≥gica de pagina√ß√£o

SERVICES E HELPERS
------------------

1. apiClient (client/lib/api-client.ts)
   - Responsabilidade: Cliente API centralizado
   - M√©todos:
     * apiClient.chat.sendMessage(message, conversationId?, context?)
     * apiClient.chat.getConversation(conversationId)
     * apiClient.documents.upload(file)
     * apiClient.documents.getAll()
     * apiClient.documents.delete(id)
   - Funcionalidades:
     * Tratamento de erros
     * Rate limiting (429)
     * Parsing de respostas JSON/texto

2. utils.ts (client/lib/utils.ts)
   - Fun√ß√£o: cn(...classes) - merge de classes Tailwind

PADR√ïES DE C√ìDIGO
-----------------

1. Gera√ß√£o de IDs √∫nicos:
   function generateId() {
     return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
   }

2. Estrutura de mensagem:
   interface Message {
     id: string;
     role: 'user' | 'assistant';
     content: string;
     timestamp: Date;
   }

3. Estado de loading:
   const [loading, setLoading] = useState(false);
   // Durante requisi√ß√£o
   setLoading(true);
   try {
     // ...
   } finally {
     setLoading(false);
   }

================================================================================
6Ô∏è‚É£  L√ìGICA DE NEG√ìCIO
================================================================================

REGRAS DE NEG√ìCIO PRINCIPAIS
----------------------------

1. Separa√ß√£o de contextos:
   - sabichao: Usa RAG, focado em documentos da empresa
   - support: N√£o usa RAG, focado em processos do sistema

2. ConversationId:
   - Formato: {context}-{uuid}
   - Permite m√∫ltiplas conversas por utilizador
   - Hist√≥rico isolado por contexto

3. RAG (apenas 'sabichao'):
   - Busca os 3 chunks mais relevantes
   - Similaridade por cosseno
   - Contexto adicionado ao system prompt

4. Persist√™ncia:
   - Todas as mensagens s√£o salvas no MongoDB
   - Ordena√ß√£o por createdAt para hist√≥rico

FLUXOS CR√çTICOS
---------------

Fluxo: Enviar Mensagem
1. Utilizador digita mensagem
2. Valida√ß√£o: mensagem n√£o vazia
3. Adiciona mensagem ao estado local (otimista)
4. Envia para backend via API
5. Backend:
   a. Autentica utilizador
   b. Busca hist√≥rico
   c. Se 'sabichao': busca RAG
   d. Constr√≥i prompt
   e. Chama OpenAI
   f. Salva mensagens (user + assistant)
6. Retorna resposta
7. Frontend atualiza UI
8. Em caso de erro: remove mensagem otimista

Fluxo: Upload de Documento
1. Utilizador seleciona ficheiro
2. Valida√ß√£o: tipo (PDF/DOCX/TXT/MD) e tamanho (10MB)
3. Upload via FormData
4. Backend:
   a. Salva ficheiro temporariamente
   b. Cria registro no MongoDB
   c. Processa assincronamente:
      - Extrai texto
      - Divide em chunks
      - Gera embeddings
      - Salva chunks
   d. Atualiza documento com vectorIds
   e. Remove ficheiro tempor√°rio
5. Frontend atualiza lista de documentos

Fluxo: Busca RAG
1. Utilizador envia pergunta
2. Gera embedding da pergunta (text-embedding-3-small)
3. Busca todos os chunks com embeddings
4. Calcula similaridade de cosseno para cada chunk
5. Ordena por similaridade
6. Retorna top 3 chunks
7. Adiciona ao system prompt

RESTRI√á√ïES E VALIDA√á√ïES
------------------------

Frontend:
- Mensagem: n√£o vazia, trim aplicado
- Ficheiro: tipo permitido, m√°ximo 10MB
- Autentica√ß√£o: obrigat√≥ria (Clerk)

Backend:
- Rate limiting: 100 req/15min por IP
- Autentica√ß√£o: token Clerk v√°lido
- Mensagem: string n√£o vazia
- Contexto: 'sabichao' ou 'support'
- Ficheiro: tipos MIME permitidos

CONFIGURA√á√ïES POR AMBIENTE
---------------------------

Desenvolvimento:
NODE_ENV=development
PORT=3001
CLIENT_URL=http://localhost:3000

Produ√ß√£o:
NODE_ENV=production
PORT=3001
CLIENT_URL=https://yourdomain.com

Vari√°veis obrigat√≥rias:
- MONGODB_URI
- DATABASE_NAME
- CLERK_SECRET_KEY
- OPENAI_API_KEY
- OPENAI_MODEL (opcional, padr√£o: gpt-4o-mini)
- NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY
- NEXT_PUBLIC_API_URL

================================================================================
7Ô∏è‚É£  GEST√ÉO DE ESTADO E DADOS
================================================================================

ESTADO DO CHAT
--------------

Frontend (React State):
const [messages, setMessages] = useState<Message[]>([]);
const [input, setInput] = useState('');
const [loading, setLoading] = useState(false);
const [conversationId, setConversationId] = useState<string | null>(null);

- Estado local: n√£o usa Redux/Zustand
- Persist√™ncia: backend (MongoDB)
- Recupera√ß√£o: ao carregar conversa, busca hist√≥rico do backend

ESTRUTURA DOS MODELOS DE DADOS
-------------------------------

ChatMessage (MongoDB):
{
  _id: ObjectId,
  conversationId: string,  // "sabichao-uuid" ou "support-uuid"
  role: 'user' | 'assistant',
  content: string,
  createdAt: Date,
  userId: string  // Clerk ID
}

Document (MongoDB):
{
  _id: ObjectId,
  filename: string,        // Nome √∫nico do ficheiro
  originalName: string,    // Nome original
  mimeType: string,
  size: number,
  uploadedBy: string,      // Clerk ID
  uploadedAt: Date,
  processedAt?: Date,
  vectorIds?: string[],    // IDs dos chunks
  isActive: boolean
}

DocumentChunk (MongoDB):
{
  _id: ObjectId,
  documentId: string,
  chunkIndex: number,
  content: string,
  embedding?: number[],    // 1536 dimens√µes
  metadata?: {
    startChar?: number,
    endChar?: number,
    pageNumber?: number
  },
  createdAt: Date
}

ESTRAT√âGIA DE PERSIST√äNCIA
--------------------------

Hist√≥rico de Conversas:
- Persist√™ncia: Todas as mensagens salvas imediatamente
- Recupera√ß√£o: ChatModel.findByConversationId(conversationId)
- Ordena√ß√£o: sort({ createdAt: 1 }) (cronol√≥gica)
- √çndices:
  * { conversationId: 1, createdAt: 1 }
  * { userId: 1, createdAt: -1 }

Documentos e Chunks:
- Upload: Ficheiro tempor√°rio ‚Üí Extra√ß√£o ‚Üí Chunks ‚Üí Embeddings
- Processamento ass√≠ncrono: n√£o bloqueia resposta
- Soft delete: isActive: false (n√£o remove chunks imediatamente)
- Limpeza: Ao deletar documento, remove chunks associados

================================================================================
8Ô∏è‚É£  AUTENTICA√á√ÉO E SEGURAN√áA
================================================================================

AUTENTICA√á√ÉO
------------

Frontend (Clerk):
- Integra√ß√£o: @clerk/nextjs
- Middleware: middleware.ts protege rotas
- Token: obtido via auth().getToken()

Backend (Clerk):
- Verifica√ß√£o: @clerk/backend - verifyToken()
- Middleware: auth.middleware.ts em todas as rotas protegidas
- Fluxo:
  1. Frontend obt√©m token do Clerk
  2. Envia no header: Authorization: Bearer {token}
  3. Backend verifica token
  4. Busca/cria utilizador no MongoDB
  5. Adiciona req.user ao request

CONTROLO DE ACESSOS
-------------------

Roles:
- admin: Acesso total
- user: Acesso limitado
- Atribui√ß√£o:
  * Primeiro utilizador: admin
  * Emails na lista adminEmails: admin
  * Resto: user

Middleware de roles:
- role.middleware.ts: verifica role antes de acessar recursos

PROTE√á√ÉO DE DADOS
-----------------

Rate Limiting:
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // 100 requests por IP
});
app.use('/api/', limiter);

Helmet:
- Headers de seguran√ßa
- Prote√ß√£o contra XSS, clickjacking, etc.

CORS:
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true,
}));

Valida√ß√£o de ficheiros:
- Tipos MIME permitidos
- Tamanho m√°ximo: 10MB
- Valida√ß√£o no frontend e backend

BOAS PR√ÅTICAS IMPLEMENTADAS
----------------------------

1. Tokens nunca expostos no frontend (via API proxy)
2. Valida√ß√£o de input (Zod no backend)
3. Sanitiza√ß√£o de ficheiros (valida√ß√£o de tipo)
4. √çndices MongoDB para performance
5. Tratamento de erros sem expor detalhes internos
6. Logs de seguran√ßa (sem tokens)

================================================================================
9Ô∏è‚É£  INTEGRA√á√ÉO COM IA
================================================================================

SERVI√áO DE IA UTILIZADO
-----------------------
- OpenAI API
- Modelo de chat: gpt-4o-mini (configur√°vel)
- Modelo de embeddings: text-embedding-3-small (1536 dimens√µes)

CONFIGURA√á√ÉO DO MODELO
----------------------

Chat:
const completion = await openai.chat.completions.create({
  model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
  messages: messagesToSend,
  temperature: 0.7,
  max_tokens: 1000,
});

Embeddings:
const response = await openai.embeddings.create({
  model: 'text-embedding-3-small',
  input: text,
});

ESTRAT√âGIA DE PROMPTS
---------------------

System Prompts:

1. MySabich√£o (sabichao):
   - Foco: dados e documentos da empresa
   - RAG: usa contexto dos documentos
   - Tom: profissional e objetivo
   - Idioma: portugu√™s brasileiro

2. Suporte (support):
   - Foco: processos e uso do sistema
   - Sem RAG
   - Tom: passo-a-passo e claro
   - Idioma: portugu√™s brasileiro

Constru√ß√£o do prompt:
- Base prompt: getSystemPrompt(chatContext)
- Se houver contexto RAG: adiciona ao system prompt
- Mensagens da conversa: adicionadas ao array de mensagens

LIMITES, CUSTOS E OTIMIZA√á√ïES
------------------------------

Limites:
- Rate limiting: 100 req/15min (backend)
- Max tokens: 1000 por resposta
- Chunks RAG: top 3 mais relevantes
- Tamanho de ficheiro: 10MB

Custos (estimativa):
- GPT-4o-mini: ~$0.15/1M input tokens, ~$0.60/1M output tokens
- text-embedding-3-small: ~$0.02/1M tokens

Otimiza√ß√µes:
- Modelo mais barato (gpt-4o-mini)
- Max tokens limitado (1000)
- Embeddings pequenos (text-embedding-3-small)
- Apenas 3 chunks por busca

OTIMIZA√á√ïES IMPLEMENTADAS
-------------------------

1. Chunks com overlap (200 chars) para contexto
2. Busca sem√¢ntica (n√£o busca todos os chunks)
3. Processamento ass√≠ncrono de documentos
4. Cache de embeddings (j√° calculados)
5. Rate limiting para evitar custos excessivos

MELHORIAS E ABSTRA√á√ïES
----------------------

Abstra√ß√µes poss√≠veis:

1. Service de IA gen√©rico:
   interface AIService {
     generateResponse(messages, systemPrompt): Promise<string>;
     generateEmbedding(text): Promise<number[]>;
   }
   Permite trocar OpenAI por outro provedor

2. Configura√ß√£o de modelos:
   const AI_CONFIG = {
     chat: { model: 'gpt-4o-mini', temperature: 0.7, maxTokens: 1000 },
     embedding: { model: 'text-embedding-3-small' },
   };

3. Cache de embeddings:
   - Evitar recalcular embeddings id√™nticos
   - Redis ou MongoDB para cache

4. Streaming de respostas:
   - Respostas em tempo real
   - Melhor UX

================================================================================
üîü  GUIA DE REPLICA√á√ÉO PARA NOVO PROJETO
================================================================================

PASSO 1: ESTRUTURA BASE
-----------------------

1.1 Criar estrutura de pastas:
novo-projeto/
‚îú‚îÄ‚îÄ client/
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ lib/
‚îî‚îÄ‚îÄ server/
    ‚îî‚îÄ‚îÄ src/
        ‚îú‚îÄ‚îÄ config/
        ‚îú‚îÄ‚îÄ controllers/
        ‚îú‚îÄ‚îÄ models/
        ‚îú‚îÄ‚îÄ routes/
        ‚îú‚îÄ‚îÄ services/
        ‚îî‚îÄ‚îÄ middleware/

1.2 Instalar depend√™ncias:

Backend:
npm install express cors dotenv helmet express-rate-limit
npm install @clerk/backend mongodb openai
npm install multer pdf-parse mammoth uuid zod
npm install -D typescript tsx @types/express @types/node

Frontend:
npm install next@16 react@19 react-dom@19
npm install @clerk/nextjs tailwindcss
npm install framer-motion lucide-react
npm install react-hook-form zod @hookform/resolvers
npm install sonner recharts
npm install -D typescript @types/react @types/node

PASSO 2: CONFIGURA√á√ÉO BASE
--------------------------

2.1 Vari√°veis de ambiente:

Backend (.env):
MONGODB_URI=mongodb://localhost:27017
DATABASE_NAME=novo_projeto
CLERK_SECRET_KEY=sk_test_...
OPENAI_API_KEY=sk-...
OPENAI_MODEL=gpt-4o-mini
PORT=3001
CLIENT_URL=http://localhost:3000
NODE_ENV=development

Frontend (.env.local):
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
NEXT_PUBLIC_API_URL=http://localhost:3001

2.2 Configura√ß√£o do banco:
Copiar server/src/config/database.ts e adaptar nome da base de dados.

PASSO 3: COMPONENTES REUTILIZ√ÅVEIS
---------------------------------

3.1 Copiar componentes UI:
- V0AIChat ‚Üí client/components/ui/v0-ai-chat.tsx
- ExpandableChat ‚Üí client/components/ui/expandable-chat.tsx
- ChatBubble ‚Üí client/components/ui/chat-bubble.tsx
- ChatMessageList ‚Üí client/components/ui/chat-message-list.tsx
- ChatInput ‚Üí client/components/ui/chat-input.tsx

3.2 Adaptar componentes:
- Alterar textos e placeholders
- Ajustar estilos (cores, tamanhos)
- Adaptar quick actions se necess√°rio

PASSO 4: BACKEND - SERVI√áOS
----------------------------

4.1 Servi√ßo OpenAI:
Copiar server/src/services/openai.service.ts:
- Adaptar system prompts ao novo contexto
- Ajustar configura√ß√µes (temperature, max_tokens)

4.2 Servi√ßo RAG (se necess√°rio):
Copiar server/src/services/rag.service.ts:
- Ajustar CHUNK_SIZE e CHUNK_OVERLAP se necess√°rio
- Manter l√≥gica de similaridade

4.3 Processador de documentos (se necess√°rio):
Copiar server/src/services/document-processor.service.ts:
- Adicionar suporte a outros tipos de ficheiro se necess√°rio

PASSO 5: BACKEND - CONTROLLERS E ROTAS
---------------------------------------

5.1 Chat Controller:
Copiar server/src/controllers/chat.controller.ts:
- Adaptar l√≥gica de contexto
- Ajustar valida√ß√µes

5.2 Rotas:
Copiar server/src/routes/chat.routes.ts:
- Manter estrutura de autentica√ß√£o

5.3 Middleware de autentica√ß√£o:
Copiar server/src/middleware/auth.middleware.ts:
- Ajustar lista de adminEmails se necess√°rio
- Manter l√≥gica de cria√ß√£o de utilizador

PASSO 6: FRONTEND - INTEGRA√á√ÉO
-------------------------------

6.1 API Client:
Copiar client/lib/api-client.ts:
- Adaptar endpoints se necess√°rio
- Manter estrutura de fetchWithAuth

6.2 Componente de chat:
Criar componente principal:
// client/components/chat/chat-content.tsx
export function ChatContent() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [conversationId, setConversationId] = useState<string | null>(null);

  const sendMessage = async () => {
    // L√≥gica similar a MySabichaoContent
  };

  return (
    <V0AIChat
      value={input}
      onChange={setInput}
      onSend={sendMessage}
      loading={loading}
      messages={messages}
      placeholder="Sua mensagem aqui..."
      title="Seu Chat"
    />
  );
}

6.3 P√°gina:
// client/app/chat/page.tsx
import { ChatContent } from '@/components/chat/chat-content';

export default function ChatPage() {
  return <ChatContent />;
}

PASSO 7: MODELOS DE DADOS
-------------------------

7.1 Copiar modelos:
- ChatModel ‚Üí server/src/models/chat.model.ts
- DocumentModel ‚Üí server/src/models/document.model.ts (se necess√°rio)
- DocumentChunkModel ‚Üí server/src/models/document-chunk.model.ts (se necess√°rio)

7.2 Adaptar tipos:
Copiar server/src/types/index.ts e adaptar:
- Remover tipos n√£o utilizados
- Adicionar tipos espec√≠ficos do novo projeto

PASSO 8: CONFIGURA√á√ÉO DO SERVIDOR
---------------------------------

8.1 index.ts:
Copiar estrutura de server/src/index.ts:
- Ajustar rotas
- Manter middlewares de seguran√ßa
- Ajustar inicializa√ß√£o do banco

PASSO 9: TESTES E VALIDA√á√ÉO
----------------------------

9.1 Testar fluxo completo:
1. Autentica√ß√£o: login com Clerk
2. Enviar mensagem: verificar resposta da IA
3. Hist√≥rico: verificar persist√™ncia
4. RAG (se aplic√°vel): upload documento e testar busca

9.2 Ajustes finais:
- Ajustar system prompts
- Personalizar UI
- Configurar vari√°veis de ambiente de produ√ß√£o

O QUE PODE SER REAPROVEITADO SEM ALTERA√á√ïES
--------------------------------------------

1. Componentes UI base:
   - V0AIChat
   - ExpandableChat
   - ChatBubble
   - ChatMessageList
   - ChatInput

2. Servi√ßos backend:
   - openai.service.ts (apenas ajustar prompts)
   - rag.service.ts (l√≥gica de embeddings)
   - document-processor.service.ts

3. Middleware:
   - auth.middleware.ts (apenas ajustar adminEmails)
   - Rate limiting
   - CORS

4. Utilit√°rios:
   - api-client.ts (estrutura)
   - utils.ts (cn function)

O QUE DEVE SER CONFIGUR√ÅVEL
---------------------------

1. System prompts:
   - Personalizar para o contexto do novo projeto
   - Ajustar tom e foco

2. Nomes e textos:
   - T√≠tulos, placeholders, mensagens
   - Quick actions

3. Configura√ß√µes de IA:
   - Modelo (gpt-4o-mini, gpt-4, etc.)
   - Temperature
   - Max tokens

4. Estrutura de dados:
   - Campos adicionais nos modelos
   - Valida√ß√µes espec√≠ficas

5. Autentica√ß√£o:
   - Lista de adminEmails
   - Regras de role

================================================================================
1Ô∏è‚É£1Ô∏è‚É£  BOAS PR√ÅTICAS E RECOMENDA√á√ïES
================================================================================

MELHORIAS ARQUITETURAIS
-----------------------

1. Abstra√ß√£o do servi√ßo de IA:
   interface AIService {
     generateResponse(...): Promise<string>;
     generateEmbedding(...): Promise<number[]>;
   }
   Facilita trocar OpenAI por outro provedor.

2. Cache de embeddings:
   - Evitar recalcular embeddings id√™nticos
   - Redis ou MongoDB para cache

3. Queue para processamento:
   - Bull/BullMQ para processar documentos
   - Retry autom√°tico em caso de falha

4. Streaming de respostas:
   - Respostas em tempo real
   - Melhor UX

5. Testes:
   - Unit tests para servi√ßos
   - Integration tests para fluxos cr√≠ticos
   - E2E tests para fluxos principais

PONTOS DE ATEN√á√ÉO AO REPLICAR
------------------------------

1. Vari√°veis de ambiente:
   - N√£o commitar .env
   - Documentar vari√°veis obrigat√≥rias
   - Valida√ß√£o na inicializa√ß√£o

2. Autentica√ß√£o:
   - Verificar token em todas as rotas protegidas
   - Tratar expira√ß√£o de token
   - Logout adequado

3. Rate limiting:
   - Configurar limites adequados
   - Mensagens de erro claras
   - Retry-After header

4. Processamento ass√≠ncrono:
   - N√£o bloquear resposta do upload
   - Tratar erros em background
   - Status de processamento vis√≠vel

5. Seguran√ßa de ficheiros:
   - Valida√ß√£o de tipo no frontend e backend
   - Sanitiza√ß√£o de nomes de ficheiro
   - Limite de tamanho
   - Scan de v√≠rus (opcional)

ERROS COMUNS A EVITAR
---------------------

1. N√£o validar input:
   - Sempre validar no frontend e backend
   - Usar Zod para valida√ß√£o

2. Expor tokens:
   - Nunca expor tokens no frontend
   - Usar API proxy para adicionar token

3. N√£o tratar erros:
   - Try/catch em todas as opera√ß√µes ass√≠ncronas
   - Mensagens de erro claras
   - Logs adequados

4. Performance:
   - √çndices MongoDB
   - Limitar resultados de queries
   - Pagina√ß√£o quando necess√°rio

5. Estado inconsistente:
   - Transa√ß√µes para opera√ß√µes cr√≠ticas
   - Valida√ß√£o antes de salvar
   - Rollback em caso de erro

ESCALABILIDADE E MANUTENIBILIDADE
----------------------------------

Escalabilidade:

1. Base de dados:
   - √çndices adequados
   - Sharding se necess√°rio
   - Replica√ß√£o para leitura

2. Cache:
   - Redis para cache de embeddings
   - Cache de respostas frequentes

3. Processamento:
   - Queue para tarefas pesadas
   - Workers para processamento paralelo

4. API:
   - Rate limiting por utilizador
   - Throttling
   - Circuit breaker para servi√ßos externos

Manutenibilidade:

1. C√≥digo:
   - TypeScript strict mode
   - ESLint + Prettier
   - Documenta√ß√£o de fun√ß√µes complexas

2. Estrutura:
   - Separa√ß√£o clara de responsabilidades
   - Services reutiliz√°veis
   - Componentes modulares

3. Logs:
   - Logs estruturados
   - N√≠veis de log (debug, info, error)
   - Contexto nos logs

4. Monitoriza√ß√£o:
   - Health checks
   - M√©tricas de performance
   - Alertas para erros cr√≠ticos

================================================================================
üìå  RESUMO EXECUTIVO
================================================================================

COMPONENTES PRINCIPAIS PARA REPLICAR
-------------------------------------

1. Frontend:
   - V0AIChat (interface de chat)
   - ExpandableChat (chat expans√≠vel)
   - apiClient (cliente API)
   - Componentes UI base

2. Backend:
   - ChatController (l√≥gica de chat)
   - OpenAIService (integra√ß√£o IA)
   - RAGService (busca sem√¢ntica)
   - AuthMiddleware (autentica√ß√£o)

3. Infraestrutura:
   - MongoDB (persist√™ncia)
   - Clerk (autentica√ß√£o)
   - OpenAI (IA)

FLUXO CR√çTICO REPLIC√ÅVEL
-----------------------

Utilizador ‚Üí Frontend ‚Üí API Proxy ‚Üí Backend ‚Üí OpenAI ‚Üí MongoDB ‚Üí Resposta

CONFIGURA√á√ïES ESSENCIAIS
------------------------

- Vari√°veis de ambiente (Clerk, OpenAI, MongoDB)
- System prompts personalizados
- Rate limiting adequado
- Valida√ß√µes de seguran√ßa

================================================================================
FIM DA DOCUMENTA√á√ÉO
================================================================================

Esta documenta√ß√£o cobre todos os aspetos principais do projeto MySabich√£o.
Use como refer√™ncia para replicar a solu√ß√£o em novos projetos, adaptando
conforme necess√°rio ao contexto espec√≠fico.
